<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Topics</title>
</head>

<body>
  <div class="main">
    <!-- How JavaScript works in the browsers -->
    <div class="content">
      <h1>How Javascript works in browsers</h1>
      <p>
        JavaScript is a client-side scripting language, which means that it
        runs on the client side, or in other words, in the web browser. When a
        user loads a web page that includes JavaScript code, the web browser's
        has a <b>JavaScript Engine</b> that interprets and executes that code.
      </p>
      <h2>What is JavaScript Engine</h2>
      <p>
        A <b>JavaScript Engine</b> is a computer program that interprets and
        executes JavaScript code. It is responsible for running JavaScript
        programs in web browsers, server-side environments, and other contexts
        where JavaScript is used.
      </p>
      <p>
        When JavaScript code is executed by a JavaScript engine, the following
        processes happen:
      </p>
      <ul>
        <li>
          <p>
            <b>Parser:</b> The engine parses the JavaScript code to create an
            abstract syntax tree (AST), which is a representation of the code
            in a format that's easier for the engine to work with.
          </p>
        </li>
        <li>
          <p>
            <b>AST: </b>In JavaScript, AST stands for Abstract Syntax Tree. It
            is a data structure that represents the source code of a program
            in a hierarchical form( parent-child relationships). The AST is
            generated by parsing the code and breaking it down into its
            individual components, such as variables, functions, statements,
            and expressions.
          </p>
          <p>
            The AST is generated by parsing the code, which involves breaking
            it down into its individual components and creating a tree-like
            structure that represents the structure of the code. Once
            generated, the AST can be used for various purposes, such as code
            analysis, optimization, and transformation.
          </p>
          <p>
            Developers use ASTs for a variety of purposes, such as analyzing
            code, optimizing code, and transforming code. Tools like Babel and
            TypeScript use ASTs to convert code written in one version of
            JavaScript to another version or to add type annotations to the
            code
          </p>
          <img src="/imges/AST.png" alt="" width="600px" /><br />
          <img src="/imges/AST2.png" alt="" width="600px" />
          <p>
            In summary, an AST is a hierarchical representation of the source
            code of a program, which is useful for analyzing, optimizing, and
            transforming code.
          </p>
        </li>
        <li>
          <p>
            <b>Compilation: </b>The engine compiles the AST into machine code,
            which is a low-level representation of the code that can be
            executed by the computer's processor.
          </p>
        </li>
        <li>
          <p>
            <b>Optimization: </b>The engine applies various optimization
            techniques to the compiled code to make it run faster and more
            efficiently. These techniques include things like inlining
            functions, reducing redundant code, and optimizing loops.
          </p>
        </li>
        <li>
          <p>
            <b>Execution: </b>The engine executes the compiled code, running
            it line by line and performing any necessary operations as it
            goes. As the code is executed, it may interact with the Document
            Object Model (DOM) in the case of browser-based JavaScript, or
            other APIs and services depending on the environment it's running
            in.
          </p>
        </li>
        <li>
          <p>
            Garbage Collection: <b></b>The engine tracks which objects in
            memory are no longer being used by the code, and frees up the
            memory they were using in a process called garbage collection.
          </p>
        </li>
      </ul>
      <img src="/imges/jsEngine.png" alt="" width="600px" />
      <p>
        These processes happen very quickly and continuously as the JavaScript
        code is being executed. By optimizing these processes, JavaScript
        engines can execute code faster and more efficiently, which ultimately
        leads to better performance for the applications running on them.
      </p>
      <h2>Some popular JavaScript engines</h2>
      <ol>
        <li>
          V8: Developed by Google, it is used in the Google Chrome browser and
          the Node.js runtime.
        </li>
        <li>
          SpiderMonkey: Developed by Mozilla, it is used in the Firefox
          browser.
        </li>
        <li>
          JavaScriptCore: Developed by Apple, it is used in the Safari browser
          and the iOS operating system.
        </li>
        <li>
          Chakra: Developed by Microsoft, it is used in the Microsoft Edge
          browser and the Internet Explorer browser.
        </li>
        <li>
          Nashorn: Developed by Oracle, it is used in the Java Virtual Machine
          (JVM).
        </li>
      </ol>
    </div>
    <div class="content">
      <h1>Execution Context</h1>
      <p>
        In JavaScript, an execution context is an abstract concept (Entites
        that have not physical or they have no direct representation in the
        physical world) that defines the environment in which JavaScript code
        is executed or An execution context is like a container that holds
        information about a specific section of code as it's being executed.
        It keeps track of things like variables, functions, and objects that
        are in scope, and it also determines the value of the "this" keyword.
        Every time a function is invoked, a new execution context is created,
        which contains information about the function call, such as the value
        of the "this" keyword, the function arguments, and the scope chain.
      </p>
      <p>There are three types of execution contexts in JavaScript</p>
      <ol>
        <li>
          <p>
            <b>Global Execution Context: </b> This is
            the default context in which JavaScript code is executed. It
            represents the top-level scope of a JavaScript program and
            contains global variables, functions, and objects.
          </p>
          <ul>
            <li>
              The Global Object: When your JavaScript program starts, the
              global execution context is created automatically by the
              JavaScript engine and added to the execution stack. It contains the global object (e.g.,
              <b>window</b> in the browser or <b>global</b> in Node.js), as
              well as any globally defined variables, functions, and objects.
            </li>
            <li>
              The Outer Environment: The outer environment of the global
              execution context is null because It is the outermost context
              and has no other surrounding context. Therefore, its outer
              environment reference is set to null, since it is the outermost
              context and has no other enclosing context.
            </li>
          </ul>
          <p>
            The global execution context is always present in the execution
            stack, and it's always at the bottom of the stack. When a function
            is called, a new execution context is created for that function
            and added to the top of the stack.
          </p>
          <p>
            This means that any variables or functions that are defined in the
            global context are not enclosed in any other context and are
            globally accessible throughout the program. They are not nested
            inside any other function or block of code, and so they are not
            subject to the scope chain or closure.
          </p>
        </li>
        <li>
          <p>
            <b>Function Execution Context: </b>This is the execution context
            created when a function is called. It contains information about
            the function call, such as the value of the "this" keyword and the
            function arguments. Each function call creates a new function
            execution context.
          </p>
        </li>
        <li>
          <p>
            <b>Eval Execution Context</b>This is the execution context created
            when the "eval" function is called. It allows you to execute
            JavaScript code dynamically, but it is generally considered to be
            a bad practice and should be avoided.
          </p>
        </li>
      </ol>
      <h2>Execuation Stack</h2>
      <p>
        In JavaScript, the execution stack (also called the call stack) is a
        data structure that stores information about the currently executing
        functions. Every time a function is called, a new execution context is
        created and pushed onto the top of the execution stack. When the
        function completes, its execution context is popped off the stack, and
        control returns to the calling function.
      </p>
      <p>
        Let's take an example to illustrate how the execution stack works:
      </p>
      <pre><code>function outer() {
  console.log("outer");
  inner();
}

function inner() {
  console.log("inner");
}

outer();</code></pre>
      <p>
        First of all Global Execuation context is created automatically it alwyas at the bottom of the stack and When
        the outer function is called, a new execution context for <b>outer function</b>
        is created and pushed onto the top of the execution stack. The first
        statement in outer is a call to the console.log function, which
        outputs "outer" to the console. Next, outer calls the inner function,
        so a new execution context for <b>inner</b> is created and pushed onto the
        top of the stack. The first statement in inner is also a call to
        console.log, which outputs "inner" to the console. Once inner
        completes, its execution context is popped off the stack, and control
        returns to outer, which also completes and is popped off the stack.
        Finally, the entire call stack is empty, and the program completes.
      </p>
      <p>
        This process continues for each nested function call, creating a stack
        of execution contexts that are resolved in a last-in, first-out (LIFO)
        order.
      </p>
      <p>
        The execution stack is a fundamental concept in JavaScript, as it
        determines the order in which functions are executed and how the
        program flows from one function call to the next. Understanding how
        the execution stack works is crucial for writing correct and efficient
        JavaScript code.
      </p>
      <h2>Why Global Execuation Context is automatically created and added to Execuation Stack</h2>
      <p>The global execution context is automatically created by the JavaScript engine when your code is first run
        because it represents the overall scope and environment of your entire program. All JavaScript code runs inside
        this context, and it's used to define global variables and functions that are accessible throughout your
        program.

      </p>
      <p>Creating the global execution context at the beginning of your program ensures that all globally defined
        variables and functions are available before any other code is executed. This means that you can define global
        variables and functions at the top of your file or script, and then use them in any other part of your program.

      </p>
      <p>Additionally, by creating the global execution context as the first context in the execution stack, it ensures
        that all other contexts created during the execution of your program have access to the global scope. This
        allows functions defined in different contexts to reference and modify global variables and functions as needed.

      </p>
      <p>So, the global execution context is created automatically in the execution stack to provide a consistent and
        predictable environment for your JavaScript program, and to ensure that globally defined variables and functions
        are available throughout your program.



      </p>
    </div>
    <div class="content">
      <h1>Synchronous in JS</h1>
      <p>Synchronous means the code runs in a particular sequence of instruction given in the program.Each instruction
        waits for the previous instruction to complete its execution</p>
      <h1>Asynchronous</h1>
      <p>
        Due to Synchronous programming sometimes important instructions get blocked due to some previous
        instruction,which causes delay in UI. Asynchronous code execution allows to execute next instruction immediately
        and does't block the flow.
      <pre><code>console.log("1");
console.log("2");
setTimeout(() => {
    console.log("3");
}, 2000);
console.log("4");</code></pre>due to Synchronous last code is blocked until the setTimeout function execution is
      complete.
      </p>
    </div>
    <div class="content">
      <h1>Call Back hell</h1>
      <p>
        A function execute in another function is called callback.
      <pre><code>
function getData(dataID, getNextData) {
  console.log(dataID);
  setTimeout(() => {
    if (getNextData) {
      getNextData();
    }
  }, 2000);
}
//CallBack Hell
getData(1, () => {
  getData(2, () => {
    getData(3, () => {
      getData(4);
    });
  });
});
          </code></pre>This is Called CallBack hell because we enter a callback in Callback.this style is difficult to
      understand
      </p>
    </div>
    <div class="content">
      <h1>Promises</h1>
      <p>Promises is for "eventual" completion of task .it is object in js <br>
        it is a solution to callback hell.
      <pre><code>
const getPromise=()=>{
    return new Promise((resolve,reject)=>{
        console.log("I am A Promise");
        resolve("success");
        //reject("Network error");
    })
}
// resolve and reject are callbacks provided by js
let promise=getPromise();
promise.then((result)=>{
    console.log("promise fulfilled",result)
})
//catch for caching errors
promise.catch((error)=>{
    console.log("error",error)
})
      </code></pre>
      <h2>Example 2</h2>
      <pre><code>
function asyncFun1(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            console.log("data1");
            resolve("success");
        },2000);
    });
}
function asyncFun2(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            console.log("data2");
            resolve("success");
        },2000);
    });
}
console.log("fetching data1 ...");
let p1=asyncFun1();
p1.then((result)=>{
    console.log("fetching data2 ...")
    p2=asyncFun2();
})
      </code></pre>
      <h2>Example 3</h2>
      <pre><code>
//this function is created by the API we just resolve it
function getData(dataID){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            console.log("data",dataID);
            resolve("success");
        },2000);
    });
}

console.log("fetching data1 ...");
getData(1).then(()=>{
    console.log("fetching data2 ...")
    getData(2).then(()=>{
        console.log("fetching data3 .....")
        getData(3);
    })
})
      </code></pre>
      </p>
    </div>
    <div class="content">
      <h1>Async-Await</h1>
      <p>async function always returns a promise.
        <br>
        async function myFunc(){...}
        <br>
        await pauses the execution of its surrounding async function until the promise is settled.
      </p>
      <pre><code>
async function hello(){
    console.log("hello")
}
// this function return always Promise compulsory because of async keyword
      </code></pre>
      <h2>Example</h2>
      <pre><code>
        //this function is created by the API we just resolve it
function getData(dataID){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            console.log("data",dataID);
            resolve("success");
        },2000);
    });
}

//async-await
async function getAllData(){
    console.log("Getting data 1 ....");
    await getData(1);
    console.log("Getting data 2 .....");
    await getData(1);
    console.log("Getting data 3 ....");
    await getData(1);
    
  }
  
  //await keyword used just in the async function. not used namely.
</code></pre>
<p>IIFE: Immediately invoked Function Expressions <br> IIFE is a function that is called immediately as soon as it is defined . <br> used this expression for calling async-await function execute automatic and  not need for call async function but not used again this async function </p>
<a href="https://www.youtube.com/watch?v=d3jXofmQm44">Resources Link</a>
</div>
</div>
</body>

</html>